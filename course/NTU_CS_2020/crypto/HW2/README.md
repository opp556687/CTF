---
tags: 2020 程式安全
---
# HW2
## RSA
### 題目分析
* 題目把flag拿去做RSA的加密並回傳加密後的密文以及n
* 加密的參數取一個512bit的質數當作p一個和`2*p`最接近的質數當作q1還有和`3*q1`最接近的質數q2三個相乘作為n並用65537當作e
### 漏洞
* 生成n的三個質數的方式不夠亂很容易被找出來
* 因為三個質數離太近所以當一個n裡面其中一個數字被找出來之後就可以把全部的p q1 q2都找出來
* 如果p, q1, q2全部都找出來之後就能夠去算出私鑰d就能夠把明文反解回來
### Exploit
* 因為q1會離`2*p`很近q2離`3*q1`很近而`n=p*q1*q2`所以n跟`p*(2*p)*(6*p)`很接近
* n/12再開三次方根就會得到一個離p很近的數字之後再乘2找最接近的質數就能得到q1
* 得到q1之後再找離`3*q1`最接近的質數就會得到q2把`n/(q1*q2)`之後就能得到p
* 得到p, q1, q2之後去算歐拉函數`phi = (p-1) * (q1-1) * (q2-1)`再來就可以求出私鑰d
* 算出d之後然後就可以用`pow(c, d, n)`去反解出明文
```python=
from Crypto.Util.number import *
from gmpy2 import next_prime, iroot

n = 22001778874542774315484392481115711539281104740723517828461360611903057304469869336789715900703500619163822273767393143914615001907123143200486464636351989898613180095341102875678204218769723325121832871221496816486100959384589443689594053640486953989205859492780929786509801664036223045197702752965199575588498118481259145703054094713019549136875163271600746675338534685099132138833920166786918380439074398183268612427028138632848870032333985485970488955991639327
c = 1067382668222320523824132555613324239857438151855225316282176402453660987952614935478188752664288189856467574123997124118639803436040589761488611318906877644244524931837804614243835412551576647161461088877884786181205274671088951504353502973964810690277238868854693198170257109413583371510824777614377906808757366142801309478368968340750993831416162099183649651151826983793949933939474873893278527484810417812120138131555544749220438456366110721231219155629863865

e = 65537
q1 = next_prime(iroot(n // 12, 3)[0]*2)
q2 = next_prime(q1 * 3)
p = n // q1 // q2
phi = (p-1) * (q1-1) * (q2-1)
d = inverse(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
```
>FLAG{Ew9xeANumjDr6bXemHsh}
## LSB
### 題目分析
* 題目是一個RSA的oracle的server一開始會輸出n和密文c然後會把使用者輸入的密文去解密之後輸出解密後 mod 3的結果
### 漏洞
* 因為server會把mod 3之後的結果輸出所以就可以做LSB oracle attack
### Exploit
* 如果輸入的內容是`c*(3^e)`解出來的明文會是3m所以就可以把n分成三份假設m會落在0到n之間三份裡面的其中一份
* 如果m落在0到n/3之間會得到3m mod n mod 3結果會得到0因為3m會剛好是3的倍數
* 如果m落在n/3到2n/3之間會得到3m-n mod n mod 3所以得到的結果(-n) mod 3
* 如果出來的結果不是在上面就會落在2n/3到n
* 這樣就可以把m的範圍從0到n縮小到剩下n/3再送`c*(9^e)`就可以再縮小1/3
* 一直重複上面的動作就可以一直縮小範圍做到上限下限收斂之後就能找出明文
```python=
from pwn import *
from Crypto.Util.number import *

# p = process(['python3', 'server.py'])
p = remote('140.112.31.97', 30001)
n = int(p.recvline().split(b' = ')[1])
c = int(p.recvline().split(b' = ')[1])

L = 0
H = n
e = 65537
_3e = pow(3, e, n)
for _ in range(1024):
    diff = (H-L)//3
    c = (_3e * c) % n
    p.sendline(str(c))
    r = int(p.recvline().split(b' = ')[1])
    if r == 0:
        H = L+diff
    elif r == (-n)%3:
        L = L+diff
        H = H-diff
    else:
        L = H-diff
print(long_to_bytes(L))
print(long_to_bytes(H))
```
>FLAG{nF9Px2LtlNh5fJiq3QtG}